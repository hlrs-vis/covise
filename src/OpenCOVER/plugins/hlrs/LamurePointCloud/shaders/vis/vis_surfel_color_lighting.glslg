// ===================== Geometry Shader =====================
#version 420 core

INCLUDE vis_surfel_util.glsl

layout(points) in;
layout(triangle_strip, max_vertices = 4) out;

in VertexData {
    vec3  pass_ms_u;
    vec3  pass_ms_v;
    vec3  pass_point_color;
    vec3  pass_world_pos;
    vec3  pass_normal_ws;
    vec3  pass_vs_pos;
    vec3  pass_vs_normal;
    float pass_radius_ws;   // Durchmesser (vor Pixel-Clamp) — 0 bei Cut
} VertexIn[];

uniform mat4  mvp_matrix;
uniform mat4  model_view_matrix;
uniform float min_screen_size;   // Pixel-Durchmesser
uniform float max_screen_size;   // Pixel-Durchmesser
uniform float scale_projection;

out FS_IN {
    vec3  pass_point_color;
    vec2  pass_uv_coords;
    vec3  pass_world_pos;
    vec3  pass_vs_pos;
    vec3  pass_vs_normal;
    float pass_radius_ws;    // Durchmesser nach Pixel-Clamp (WS)
    float pass_screen_size;  // Durchmesser in Pixeln
} gOut;

void main() {
    // durchreichen
    gOut.pass_point_color = VertexIn[0].pass_point_color;
    gOut.pass_world_pos   = VertexIn[0].pass_world_pos;
    gOut.pass_vs_pos      = VertexIn[0].pass_vs_pos;
    gOut.pass_vs_normal   = VertexIn[0].pass_vs_normal;

    // Quad in Weltkoordinaten aufspannen
    vec3 center = VertexIn[0].pass_world_pos;
    vec3 step_u = VertexIn[0].pass_ms_u; // Radius
    vec3 step_v = VertexIn[0].pass_ms_v; // Radius

    // Skalierung und Culling mit der neuen Hilfsfunktion
    float pixel_diameter, world_radius;
    if (!scale_surfel_for_screen(
        center,
        model_view_matrix,
        scale_projection,
        min_screen_size,
        max_screen_size,
        step_u,
        step_v,
        pixel_diameter,
        world_radius
    )) {
        return;
    }

    // Werte für FS
    gOut.pass_radius_ws   = world_radius;
    gOut.pass_screen_size = pixel_diameter;

    // 4 Ecken des Billboard-Quads
    vec3 offs[4] = vec3[4](
        -step_u - step_v,
         step_u - step_v,
        -step_u + step_v,
         step_u + step_v
    );
    vec2 uvs[4] = vec2[4](
        vec2(-1.0, -1.0),
        vec2( 1.0, -1.0),
        vec2(-1.0,  1.0),
        vec2( 1.0,  1.0)
    );

    for (int i = 0; i < 4; ++i) {
        gOut.pass_uv_coords = uvs[i];
        gl_Position = mvp_matrix * vec4(center + offs[i], 1.0);
        EmitVertex();
    }
    EndPrimitive();
}
