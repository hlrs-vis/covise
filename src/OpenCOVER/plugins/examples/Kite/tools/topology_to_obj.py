#!/usr/bin/env python3
"""
Convert a regular terrain point-grid CSV (x_m,y_m,z_m) to a textured OBJ mesh.

Typical usage:
  python3 topology_to_obj.py \
    --topology-csv /path/Topology.csv \
    --ortho /path/OrthoPicGray.tiff \
    --output-obj /path/winsent_terrain.obj \
    --stride 4

Then convert OBJ -> IVE:
  osgconv --compressed /path/winsent_terrain.obj /path/winsent_terrain.ive
"""

from __future__ import annotations

import argparse
import csv
import os
import sys
from dataclasses import dataclass
from typing import Optional, Tuple

import numpy as np


@dataclass
class GridData:
    x_axis: np.ndarray  # (nx,)
    y_axis: np.ndarray  # (ny,)
    z_grid: np.ndarray  # (ny, nx)


def sniff_delimiter(path: str) -> str:
    with open(path, "r", newline="") as f:
        sample = f.read(4096)
    try:
        dialect = csv.Sniffer().sniff(sample, delimiters=",;\t")
        return dialect.delimiter
    except csv.Error:
        return ","


def load_xyz_csv(path: str, delimiter: str) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
    data = np.loadtxt(path, delimiter=delimiter, skiprows=1, dtype=np.float64)
    if data.ndim != 2 or data.shape[1] < 3:
        raise RuntimeError(f"Expected at least 3 columns in '{path}', got shape {data.shape}")
    return data[:, 0], data[:, 1], data[:, 2]


def build_grid(x: np.ndarray, y: np.ndarray, z: np.ndarray) -> GridData:
    if not (len(x) == len(y) == len(z)):
        raise RuntimeError("x/y/z column lengths differ")

    order = np.lexsort((x, y))  # primary key y, secondary key x
    x_sorted = x[order]
    y_sorted = y[order]
    z_sorted = z[order]

    x_axis = np.unique(x_sorted)
    y_axis = np.unique(y_sorted)
    nx = x_axis.size
    ny = y_axis.size
    n = x_sorted.size
    if nx * ny != n:
        raise RuntimeError(
            "Input is not a complete regular grid: "
            f"points={n}, unique_x={nx}, unique_y={ny}, unique_x*unique_y={nx*ny}"
        )

    z_grid = z_sorted.reshape((ny, nx))
    return GridData(x_axis=x_axis, y_axis=y_axis, z_grid=z_grid)


def crop_grid(
    grid: GridData,
    x_min: Optional[float],
    x_max: Optional[float],
    y_min: Optional[float],
    y_max: Optional[float],
) -> GridData:
    x_axis = grid.x_axis
    y_axis = grid.y_axis
    z_grid = grid.z_grid

    x_mask = np.ones_like(x_axis, dtype=bool)
    y_mask = np.ones_like(y_axis, dtype=bool)
    if x_min is not None:
        x_mask &= x_axis >= x_min
    if x_max is not None:
        x_mask &= x_axis <= x_max
    if y_min is not None:
        y_mask &= y_axis >= y_min
    if y_max is not None:
        y_mask &= y_axis <= y_max

    if not x_mask.any() or not y_mask.any():
        raise RuntimeError("Crop bounds produced an empty grid")

    x_new = x_axis[x_mask]
    y_new = y_axis[y_mask]
    z_new = z_grid[np.ix_(y_mask, x_mask)]
    return GridData(x_axis=x_new, y_axis=y_new, z_grid=z_new)


def downsample_grid(grid: GridData, stride: int) -> GridData:
    if stride < 1:
        raise RuntimeError("Stride must be >= 1")
    x_new = grid.x_axis[::stride]
    y_new = grid.y_axis[::stride]
    z_new = grid.z_grid[::stride, ::stride]
    if x_new.size < 2 or y_new.size < 2:
        raise RuntimeError("Downsampled grid is too small; choose a smaller stride")
    return GridData(x_axis=x_new, y_axis=y_new, z_grid=z_new)


def write_obj(
    obj_path: str,
    grid: GridData,
    texture_path: Optional[str],
    center_xy: bool,
    z_scale: float,
    z_offset: float,
    up_axis: str,
) -> None:
    x_axis = grid.x_axis.copy()
    y_axis = grid.y_axis.copy()
    z_grid = grid.z_grid.copy()
    nx = x_axis.size
    ny = y_axis.size

    if center_xy:
        x_axis -= 0.5 * (x_axis.min() + x_axis.max())
        y_axis -= 0.5 * (y_axis.min() + y_axis.max())

    z_grid = (z_grid + z_offset) * z_scale

    out_dir = os.path.dirname(os.path.abspath(obj_path))
    os.makedirs(out_dir, exist_ok=True)

    has_texture = bool(texture_path)
    mtl_name = None
    if has_texture:
        mtl_name = os.path.splitext(os.path.basename(obj_path))[0] + ".mtl"
        mtl_path = os.path.join(out_dir, mtl_name)
        with open(mtl_path, "w", encoding="utf-8") as mtl:
            mtl.write("newmtl terrain_mat\n")
            mtl.write("Ka 1.000 1.000 1.000\n")
            mtl.write("Kd 1.000 1.000 1.000\n")
            mtl.write("Ks 0.000 0.000 0.000\n")
            mtl.write("d 1.0\n")
            mtl.write("illum 1\n")
            mtl.write(f"map_Kd {os.path.basename(texture_path)}\n")

    x0, x1 = float(x_axis.min()), float(x_axis.max())
    y0, y1 = float(y_axis.min()), float(y_axis.max())
    dx = (x1 - x0) if (x1 - x0) != 0.0 else 1.0
    dy = (y1 - y0) if (y1 - y0) != 0.0 else 1.0

    def vid(ix: int, iy: int) -> int:
        return iy * nx + ix + 1

    with open(obj_path, "w", encoding="utf-8") as obj:
        obj.write("# Generated by topology_to_obj.py\n")
        obj.write(f"# grid nx={nx} ny={ny}\n")
        if has_texture and mtl_name:
            obj.write(f"mtllib {mtl_name}\n")
            obj.write("usemtl terrain_mat\n")

        # Vertices.
        for iy in range(ny):
            yv = float(y_axis[iy])
            for ix in range(nx):
                xv = float(x_axis[ix])
                zv = float(z_grid[iy, ix])
                if up_axis == "z":
                    obj.write(f"v {xv:.6f} {yv:.6f} {zv:.6f}\n")
                else:
                    # Some OBJ importers treat Y as "up". For those, write terrain
                    # as X(horizontal), Y(height), Z(horizontal).
                    obj.write(f"v {xv:.6f} {zv:.6f} {yv:.6f}\n")

        # UVs (top-left texture origin compatible: flip V).
        for iy in range(ny):
            yv = float(y_axis[iy])
            v = 1.0 - ((yv - y0) / dy)
            for ix in range(nx):
                xv = float(x_axis[ix])
                u = (xv - x0) / dx
                obj.write(f"vt {u:.6f} {v:.6f}\n")

        # Triangles (2 per cell).
        for iy in range(ny - 1):
            for ix in range(nx - 1):
                v00 = vid(ix, iy)
                v10 = vid(ix + 1, iy)
                v01 = vid(ix, iy + 1)
                v11 = vid(ix + 1, iy + 1)
                obj.write(f"f {v00}/{v00} {v10}/{v10} {v11}/{v11}\n")
                obj.write(f"f {v00}/{v00} {v11}/{v11} {v01}/{v01}\n")


def parse_args() -> argparse.Namespace:
    p = argparse.ArgumentParser(description="Convert Topology.csv grid to textured OBJ terrain.")
    p.add_argument("--topology-csv", required=True, help="Input CSV with x_m,y_m,z_m columns.")
    p.add_argument("--output-obj", required=True, help="Output OBJ path.")
    p.add_argument("--ortho", default=None, help="Optional texture image path (tiff/png/jpg).")
    p.add_argument("--delimiter", default=None, help="CSV delimiter (default: auto detect).")
    p.add_argument("--stride", type=int, default=4, help="Grid decimation factor (>=1).")
    p.add_argument("--x-min", type=float, default=None, help="Optional crop: minimum X.")
    p.add_argument("--x-max", type=float, default=None, help="Optional crop: maximum X.")
    p.add_argument("--y-min", type=float, default=None, help="Optional crop: minimum Y.")
    p.add_argument("--y-max", type=float, default=None, help="Optional crop: maximum Y.")
    p.add_argument("--center-xy", action="store_true", help="Center X/Y around 0 before export.")
    p.add_argument("--z-scale", type=float, default=1.0, help="Scale factor applied to Z.")
    p.add_argument("--z-offset", type=float, default=0.0, help="Offset added to Z before scaling.")
    p.add_argument(
        "--up-axis",
        choices=("z", "y"),
        default="z",
        help="OBJ vertical axis convention: z (default) or y.",
    )
    return p.parse_args()


def main() -> int:
    args = parse_args()
    topo_csv = os.path.abspath(args.topology_csv)
    out_obj = os.path.abspath(args.output_obj)
    ortho = os.path.abspath(args.ortho) if args.ortho else None

    if not os.path.isfile(topo_csv):
        print(f"ERROR: topology CSV not found: {topo_csv}", file=sys.stderr)
        return 2
    if ortho and not os.path.isfile(ortho):
        print(f"ERROR: ortho texture not found: {ortho}", file=sys.stderr)
        return 2

    delimiter = args.delimiter or sniff_delimiter(topo_csv)
    print(f"[info] reading CSV: {topo_csv}")
    print(f"[info] delimiter: '{delimiter}'")
    x, y, z = load_xyz_csv(topo_csv, delimiter)
    print(f"[info] points loaded: {x.size}")

    grid = build_grid(x, y, z)
    print(
        "[info] detected grid: "
        f"nx={grid.x_axis.size}, ny={grid.y_axis.size}, "
        f"x=[{grid.x_axis.min():.3f},{grid.x_axis.max():.3f}], "
        f"y=[{grid.y_axis.min():.3f},{grid.y_axis.max():.3f}], "
        f"z=[{grid.z_grid.min():.3f},{grid.z_grid.max():.3f}]"
    )

    if any(v is not None for v in (args.x_min, args.x_max, args.y_min, args.y_max)):
        grid = crop_grid(grid, args.x_min, args.x_max, args.y_min, args.y_max)
        print(
            "[info] cropped grid: "
            f"nx={grid.x_axis.size}, ny={grid.y_axis.size}, "
            f"x=[{grid.x_axis.min():.3f},{grid.x_axis.max():.3f}], "
            f"y=[{grid.y_axis.min():.3f},{grid.y_axis.max():.3f}]"
        )

    if args.stride > 1:
        grid = downsample_grid(grid, args.stride)
        print(f"[info] downsampled with stride={args.stride}: nx={grid.x_axis.size}, ny={grid.y_axis.size}")

    write_obj(
        obj_path=out_obj,
        grid=grid,
        texture_path=ortho,
        center_xy=args.center_xy,
        z_scale=args.z_scale,
        z_offset=args.z_offset,
        up_axis=args.up_axis,
    )
    print(f"[ok] wrote OBJ: {out_obj}")
    if ortho:
        print(f"[ok] wrote MTL with texture: {ortho}")
    print("[next] convert OBJ -> IVE: osgconv --compressed <obj> <ive>")
    return 0


if __name__ == "__main__":
    sys.exit(main())
