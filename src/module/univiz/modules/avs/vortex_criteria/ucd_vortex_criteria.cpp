/* This file is part of COVISE.

   You can use it under the terms of the GNU Lesser General Public License
   version 2.1 or later, see lgpl-2.1.txt.

 * License: LGPL 2+ */

/* mod_gen Version 1                                                     */
/* Module Name: "ucd vortex criteria" (Filter) (Subroutine)              */
/* Author: Filip Sadlo on basis of Ronald Peikert                        */
/* Date Created: Thu Jun  7 11:53:58 2001                                */
/*                                                                       */
/* This file is automatically generated by the Module Generator (mod_gen)*/
/* Please do not modify or move the contents of this comment block as    */
/* mod_gen needs it in order to read module sources back in.             */
/*                                                                       */
/* input 0 "ucd" ucd REQUIRED                                            */
/* param 0 "presmooth" toggle 0 0 1 */
/* output 0 "vorticity" ucd                                                */
/* output 1 "scalar" ucd                                                */
/* param 0 "quantity" radio_buttons "helicity" "helicity:vorticity mag:lambda2:z vorticity:Q:S norm:S offdiag norm:trace S (= div):S eigenvect" ":"*/
/* End of Module Description Comments                                    */
// ### to do: adapt above defs

#include <stdio.h>
#include <avs/avs.h>
#include <avs/port.h>
#include <avs/ucd_defs.h>

/* ----> START OF USER-SUPPLIED CODE SECTION #1 (INCLUDE FILES, GLOBAL VARIABLES)*/

#include <math.h>
#include "linalg.h"
#include "avs_ext.h"
#include "unstructured.h"
#include "unisys.h"

static Unstructured *unst_in = NULL;
static Unstructured *unst_in_time_deriv = NULL;

#include "vortex_criteria_impl.cpp" // ### including .cpp

void computeIt(Unstructured *unst_in, int compVelo,
               // Unstructured *unst_vorticity,
               Unstructured *unst_scalar, char *quantity);

/* <---- END OF USER-SUPPLIED CODE SECTION #1                            */

/* *****************************************/
/*  Module Description                     */
/* *****************************************/
int ucd_vortex_criteria_desc()
{

    int in_port, out_port, param;
    extern int ucd_vortex_criteria_compute(UCD_structure * ucd,
                                           UCD_structure * ucd_velo_time_deriv,
                                           // UCD_structure **vorticity,
                                           UCD_structure * *scalar,
                                           char *velocity,
                                           char *velo_time_deriv,
                                           char *quantity,
                                           int smoothing_range);

    AVSset_module_name("ucd vortex criteria", MODULE_FILTER);

    /* Input Port Specifications               */
    in_port = AVScreate_input_port("ucd", "ucd", REQUIRED);
    in_port = AVScreate_input_port("ucd velo time deriv", "ucd", OPTIONAL);

    /* Output Port Specifications              */
    //out_port = AVScreate_output_port("vorticity", "ucd");
    out_port = AVScreate_output_port("scalar", "ucd");

    /* Parameter Specifications                */
    param = AVSadd_parameter("velocity", "choice", "", "", ":");
    AVSconnect_widget(param, "choice_browser");

    param = AVSadd_parameter("velo time deriv", "choice", "", "", ":");
    AVSconnect_widget(param, "choice_browser");

    param = AVSadd_parameter("quantity", "choice", "helicity",
                             "helicity:velo-norm helicity:vorticity mag:z vorticity:lambda2:Q:delta:Mz hyperbolic:Mz strong hyperbolic:div accel:divergence", ":");
    AVSconnect_widget(param, "radio_buttons");

    param = AVSadd_parameter("smoothing range", "integer", 1, 1, INT_UNBOUND);
    AVSconnect_widget(param, "typein_integer");

    AVSset_compute_proc((int (*)())ucd_vortex_criteria_compute);

    /* ----> START OF USER-SUPPLIED CODE SECTION #2 (ADDITIONAL SPECIFICATION INFO)*/
    /* <---- END OF USER-SUPPLIED CODE SECTION #2                            */
    return (1);
}

/* *****************************************/
/* Module Compute Routine                  */
/* *****************************************/
int ucd_vortex_criteria_compute(UCD_structure *ucd,
                                UCD_structure *ucd_velo_time_deriv,
                                //UCD_structure **vorticity,
                                UCD_structure **scalar,
                                char *velocity,
                                char *velo_time_deriv,
                                char *quantity,
                                int smoothing_range)
{

    /* ----> START OF USER-SUPPLIED CODE SECTION #3 (COMPUTE ROUTINE BODY)   */

    /* Allocate output UCD */
    //if (*vorticity && *vorticity != ucd) UCDstructure_free (*vorticity);
    if (*scalar && *scalar != ucd)
        UCDstructure_free(*scalar);

    //UCD_structure* ucd1 = ucdClone(ucd, 3, "vorticity");
    UCD_structure *ucd2 = ucdClone(ucd, 1, "scalar");

    // input wrapper
    if (AVSinput_changed("ucd", 0))
    {
        if (unst_in)
            delete unst_in;
        unst_in = new Unstructured(ucd);
    }
    int compVelo = ucd_processCompChoice(ucd, "ucd", velocity, "velocity", 3,
                                         unst_in->getVectorNodeDataComponent());
    if (compVelo >= 0)
        unst_in->selectVectorNodeData(compVelo);

    int compVeloTimeDeriv = -1;
    if (ucd_velo_time_deriv)
    {
        if (AVSinput_changed("ucd velo time deriv", 0))
        {
            if (unst_in_time_deriv)
                delete unst_in_time_deriv;
            unst_in_time_deriv = new Unstructured(ucd_velo_time_deriv);
        }
        compVeloTimeDeriv = ucd_processCompChoice(ucd_velo_time_deriv, "ucd velo time deriv", velo_time_deriv, "velo time deriv", 3,
                                                  unst_in_time_deriv->getVectorNodeDataComponent());
        if (compVeloTimeDeriv >= 0)
            unst_in_time_deriv->selectVectorNodeData(compVeloTimeDeriv);
    }
    else
    {
        if (unst_in_time_deriv)
        {
            delete unst_in_time_deriv;
            unst_in_time_deriv = NULL;
        }
    }

    // system wrapper
    UniSys us;

    // compute velocity gradient
    if (AVSinput_changed("ucd", 0) || AVSparameter_changed("smoothing range"))
    {
        us.moduleStatus("computing gradient", 5);
        unst_in->gradient(compVelo, false, smoothing_range);
        us.moduleStatus("computing gradient", 50);
    }

    // compute velocity gradient of time derivative
    if (ucd_velo_time_deriv)
    {
        if (AVSinput_changed("ucd velo time deriv", 0) || AVSparameter_changed("smoothing range"))
        {
            us.moduleStatus("computing gradient", 5);
            unst_in_time_deriv->gradient(compVeloTimeDeriv, false, smoothing_range);
            us.moduleStatus("computing gradient", 50);
        }
    }

    // output wrappers
    //Unstructured *unst_vorticity = new Unstructured(ucd1);
    Unstructured *unst_scalar = new Unstructured(ucd2);

    // compute
    vortex_criteria_impl(&us,
                         unst_in, compVelo,
                         unst_in_time_deriv, compVeloTimeDeriv,
                         //unst_vorticity,
                         unst_scalar,
                         AVSchoice_number("quantity", quantity),
                         smoothing_range,
                         NULL);

    //*vorticity = ucd1;
    *scalar = ucd2;

    //delete unst_vorticity;
    delete unst_scalar;

    /* <---- END OF USER-SUPPLIED CODE SECTION #3              */
    return (1);
}

/* ***********************************************************************/
/* Initialization for modules contained in this file.                    */
/* ***********************************************************************/
static int((*mod_list[])()) = {
    ucd_vortex_criteria_desc
};
#define NMODS (sizeof(mod_list) / sizeof(char *))

#ifdef __cplusplus
extern "C" // Add for C++
    {
#endif

void AVSinit_modules()
{ // Modify for C++
    AVSinit_from_module_list(mod_list, NMODS);
}

#ifdef __cplusplus
} // Add for C++
#endif

/* ----> START OF USER-SUPPLIED CODE SECTION #4 (SUBROUTINES, FUNCTIONS, UTILITY ROUTINES)*/

/* <---- END OF USER-SUPPLIED CODE SECTION #4                            */
