/* This file is part of COVISE.

   You can use it under the terms of the GNU Lesser General Public License
   version 2.1 or later, see lgpl-2.1.txt.

 * License: LGPL 2+ */

/* mod_gen Version 1                                                     */
/* Module Name: "ucd Mz" (Filter) (Subroutine)              */
/* Author:Filip Sadlo                                                    */
/* Date Created: Wed Jul 4 09:20:00 2007                                */
/*                                                                       */
/* This file is automatically generated by the Module Generator (mod_gen)*/
/* Please do not modify or move the contents of this comment block as    */
/* mod_gen needs it in order to read module sources back in.             */
/*                                                                       */
/* input 0 "surface" geom REQUIRED                                       */
/* input 1 "ucd" ucd REQUIRED                                            */
/* input 2 "pick information" struct upstream_geom REQUIRED              */
/* output 0 "orth curve" field 1D 3-space 1-vector irregular float     */
/* param 0 "quantity" radio_buttons "helicity" "helicity:vorticity mag:lambda2" ":"*/
/* End of Module Description Comments                                    */
// #### to do: adapt definitions above

#include <stdio.h>
#include <avs/avs.h>
#include <avs/port.h>
#include <avs/ucd_defs.h>
#include <avs/geom.h>

/* ----> START OF USER-SUPPLIED CODE SECTION #1 (INCLUDE FILES, GLOBAL VARIABLES)*/

#include <math.h>
#include <vector>
#include <values.h>
#include <libgen.h>
#include "linalg.h"
#include "avs_ext.h"
#include "unstructured.h"
#include "dataDict.h"
#include "unisys.h"

static Unstructured *unst = NULL;

#include "Mz_impl.cpp" // #### including .cpp

char *picked_obj;

/* <---- END OF USER-SUPPLIED CODE SECTION #1                            */

/* *****************************************/
/*  Module Description                     */
/* *****************************************/
int ucd_Mz_desc()
{

    int in_port, out_port, param;
    extern int ucd_Mz_compute(UCD_structure * ucd, UCD_structure * grid, UCD_structure * *ucd_out, AVSfield_float * *trajectories,
                              float *origin_x, float *origin_y, float *origin_z,
                              int cells_x, int cells_y, int cells_z,
                              float *cell_size,
                              char *velocity,
                              int unsteady,
                              char *velocity_file,
                              int strong_hyperbolicity,
                              int ABC_steady,
                              float *start_time,
                              float *integration_time,
                              int time_intervals,
                              int integ_steps_max, int forward,
                              int smoothing_range,
                              int omit_boundary_cells,
                              int grad_neigh_disabled,
                              int execute);

    AVSset_module_name("ucd Mz", MODULE_FILTER);

    /* Input Port Specifications               */
    in_port = AVScreate_input_port("ucd", "ucd", REQUIRED);
    in_port = AVScreate_input_port("grid", "ucd", OPTIONAL);

    /* Output Port Specifications              */
    out_port = AVScreate_output_port("ucd out", "ucd");
    out_port = AVScreate_output_port("trajectories",
                                     "field 2D 3-space 2-vector irregular float");

    /* Parameter Specifications                */
    param = AVSadd_float_parameter("origin x", 0.0, FLOAT_UNBOUND, FLOAT_UNBOUND);
    AVSconnect_widget(param, "typein_real");

    param = AVSadd_float_parameter("origin y", 0.0, FLOAT_UNBOUND, FLOAT_UNBOUND);
    AVSconnect_widget(param, "typein_real");

    param = AVSadd_float_parameter("origin z", 0.0, FLOAT_UNBOUND, FLOAT_UNBOUND);
    AVSconnect_widget(param, "typein_real");

    param = AVSadd_parameter("cells x", "integer", 10, 1, INT_MAX);
    AVSconnect_widget(param, "typein_integer");

    param = AVSadd_parameter("cells y", "integer", 10, 1, INT_MAX);
    AVSconnect_widget(param, "typein_integer");

    param = AVSadd_parameter("cells z", "integer", 10, 1, INT_MAX);
    AVSconnect_widget(param, "typein_integer");

    param = AVSadd_float_parameter("cell size", 0.01, 0.0, FLOAT_UNBOUND);
    AVSconnect_widget(param, "typein_real");

    param = AVSadd_parameter("velocity", "choice", "", "", ":");
    AVSconnect_widget(param, "choice_browser");

    param = AVSadd_parameter("unsteady", "boolean", 0, 0, 1);
    AVSconnect_widget(param, "toggle");

    param = AVSadd_parameter("velocity file", "string", "", "", ":");
    AVSconnect_widget(param, "browser");

    param = AVSadd_parameter("strong hyperbolicity", "boolean", 0, 0, 1);
    AVSconnect_widget(param, "toggle");

    param = AVSadd_parameter("ABC steady", "boolean", 0, 0, 1);
    AVSconnect_widget(param, "toggle");

    param = AVSadd_float_parameter("start time", 0.0, FLOAT_UNBOUND, FLOAT_UNBOUND);
    AVSconnect_widget(param, "typein_real");

    // per time interval
    param = AVSadd_float_parameter("integration time", 0.1, 0.0, FLOAT_UNBOUND);
    AVSconnect_widget(param, "typein_real");

    param = AVSadd_parameter("time intervals", "integer", 50, 1, INT_MAX);
    AVSconnect_widget(param, "typein_integer");

    // per time interval
    param = AVSadd_parameter("integ steps max", "integer", 100, 1, INT_MAX);
    AVSconnect_widget(param, "typein_integer");

    param = AVSadd_parameter("forward", "boolean", 1, 0, 1);
    AVSconnect_widget(param, "toggle");

    param = AVSadd_parameter("smoothing range", "integer", 1, 1, INT_MAX);
    AVSconnect_widget(param, "typein_integer");

    param = AVSadd_parameter("omit boundary cells", "boolean", 0, 0, 1);
    AVSconnect_widget(param, "toggle");

    param = AVSadd_parameter("grad neigh disabled", "boolean", 1, 0, 1);
    AVSconnect_widget(param, "toggle");

    param = AVSadd_parameter("execute", "boolean", 1, 0, 1);
    AVSconnect_widget(param, "toggle");

    /* compute routine                         */
    AVSset_compute_proc((int (*)())ucd_Mz_compute);

    /* ----> START OF USER-SUPPLIED CODE SECTION #2 (ADDITIONAL SPECIFICATION INFO)*/
    /* <---- END OF USER-SUPPLIED CODE SECTION #2                            */
    return (1);
}

/* *****************************************/
/* Module Compute Routine                  */
/* *****************************************/
int ucd_Mz_compute(UCD_structure *ucd, UCD_structure *grid, UCD_structure **ucd_out, AVSfield_float **trajectories,
                   float *origin_x, float *origin_y, float *origin_z,
                   int cells_x, int cells_y, int cells_z,
                   float *cell_size,
                   char *velocity,
                   int unsteady,
                   char *velocity_file,
                   int strong_hyperbolicity,
                   int ABC_steady,
                   float *start_time,
                   float *integration_time,
                   int time_intervals,
                   int integ_steps_max, int forward, int smoothing_range,
                   int omit_boundary_cells,
                   int grad_neigh_disabled,
                   int execute)
{

    /* ----> START OF USER-SUPPLIED CODE SECTION #3 (COMPUTE ROUTINE BODY)   */

    // system wrapper
    UniSys us;

    if (ucd_findNodeCompByVeclen(ucd, 3, 0) < 0)
    {
        us.error("UCD must contain at least one 3-vect component");
        return 0;
    }

    //if (AVSparameter_changed("mode")) {
    {
        char *cp1, *cp2;

        if (grid)
        {
            AVScommand("kernel", "manipulator \"$Module:origin x\" -hide", &cp1, &cp2);
            AVScommand("kernel", "manipulator \"$Module:origin y\" -hide", &cp1, &cp2);
            AVScommand("kernel", "manipulator \"$Module:origin z\" -hide", &cp1, &cp2);
            AVScommand("kernel", "manipulator \"$Module:cells x\" -hide", &cp1, &cp2);
            AVScommand("kernel", "manipulator \"$Module:cells y\" -hide", &cp1, &cp2);
            AVScommand("kernel", "manipulator \"$Module:cells z\" -hide", &cp1, &cp2);
            AVScommand("kernel", "manipulator \"$Module:cell size\" -hide", &cp1, &cp2);
        }
        else
        {
            AVScommand("kernel", "manipulator \"$Module:origin x\" -show", &cp1, &cp2);
            AVScommand("kernel", "manipulator \"$Module:origin y\" -show", &cp1, &cp2);
            AVScommand("kernel", "manipulator \"$Module:origin z\" -show", &cp1, &cp2);
            AVScommand("kernel", "manipulator \"$Module:cells x\" -show", &cp1, &cp2);
            AVScommand("kernel", "manipulator \"$Module:cells y\" -show", &cp1, &cp2);
            AVScommand("kernel", "manipulator \"$Module:cells z\" -show", &cp1, &cp2);
            AVScommand("kernel", "manipulator \"$Module:cell size\" -show", &cp1, &cp2);
        }

        if (unsteady)
        {
            AVScommand("kernel", "manipulator \"$Module:velocity file\" -show", &cp1, &cp2);
            AVScommand("kernel", "manipulator \"$Module:start time\" -show", &cp1, &cp2);
        }
        else
        {
            AVScommand("kernel", "manipulator \"$Module:velocity file\" -hide", &cp1, &cp2);
            AVScommand("kernel", "manipulator \"$Module:start time\" -hide", &cp1, &cp2);
        }
    }

    if (*integration_time <= 0.0)
    {
        us.error("integration time must be larger than zero");
        return 0;
    }

    // input wrapper
    if (AVSinput_changed("ucd", 0))
    {
        if (unst)
            delete unst;
        unst = new Unstructured(ucd);
    }

    // process component choice selection
    int compVelo = ucd_processCompChoice(ucd, "ucd", velocity, "velocity", 3,
                                         unst->getVectorNodeDataComponent());
    if (compVelo >= 0)
        unst->selectVectorNodeData(compVelo);

    // init

    /* Allocate output UCD */
    if (*ucd_out && *ucd_out != ucd)
        UCDstructure_free(*ucd_out);
    UCD_structure *ucd1 = NULL;
    char labels[256] = "Mz.integration time";
    int components[2] = { 1, 1 };
    if (grid)
    {
        ucd1 = ucdClone(grid, 2, components, "ucd out", labels, ".");
    }
    else
    {
        ucd1 = generateUniformUCD("ucd out", *origin_x, *origin_y, *origin_z,
                                  cells_x, cells_y, cells_z,
                                  *cell_size,
                                  2, components,
                                  labels, ".");
    }
    *ucd_out = ucd1;

    // unstructured wrapper for output
    Unstructured *unst_out = new Unstructured(*ucd_out);

    // allocate field for trajectories
    if (*trajectories)
        AVSfield_free((AVSfield *)*trajectories);
    int dims[2];
    dims[0] = integ_steps_max + 1;
    dims[1] = ucd1->nnodes;
    *trajectories = (AVSfield_float *)AVSdata_alloc("field 2D 2-vector irregular 3-space float", dims);
    if (*trajectories == NULL)
    {
        AVSerror("allocation failed");
        return (0);
    }

    // field wrapper for output
    UniField *unif_traj = new UniField((AVSfield *)*trajectories);

    // compute
    if (execute)
    {
        Mz_impl(&us, unst, compVelo, unsteady, velocity_file,
                strong_hyperbolicity,
                ABC_steady,
                *start_time,
                *integration_time,
                time_intervals, integ_steps_max, forward,
                unst_out, smoothing_range,
                omit_boundary_cells, grad_neigh_disabled, unif_traj);

        // ##### work around, because there is a bug in unsetVector3CB()
        if (unst)
            delete unst;
        unst = new Unstructured(ucd);
    }

    // delete unstructured wrapper for output (but not the field)
    delete unst_out;

    // delete field wrapper (but not the field)
    delete unif_traj;

    /* <---- END OF USER-SUPPLIED CODE SECTION #3              */
    return (1);
}

/* ***********************************************************************/
/* Initialization for modules contained in this file.                    */
/* ***********************************************************************/
static int((*mod_list[])()) = {
    ucd_Mz_desc
};
#define NMODS (sizeof(mod_list) / sizeof(char *))

#ifdef __cplusplus
extern "C" // Add for C++
    {
#endif

void AVSinit_modules()
{ // Modify for C++
    AVSinit_from_module_list(mod_list, NMODS);
}

#ifdef __cplusplus
} // Add for C++
#endif

/* ----> START OF USER-SUPPLIED CODE SECTION #4 (SUBROUTINES, FUNCTIONS, UTILITY ROUTINES)*/

/* <---- END OF USER-SUPPLIED CODE SECTION #4                            */
