/* This file is part of COVISE.

   You can use it under the terms of the GNU Lesser General Public License
   version 2.1 or later, see lgpl-2.1.txt.

 * License: LGPL 2+ */

/* mod_gen Version 1                                                     */
/* Module Name: "ucd ridge surface" (Mapper) (Subroutine)                   */
/* Author: Filip Sadlo (from Ronny Peikert's ucd isosurface)             */
/* Date Created: Fri Sep 8 15:18:28 2006                                */
/*                                                                       */
/* This file is automatically generated by the Module Generator (mod_gen)*/
/* Please do not modify or move the contents of this comment block as    */
/* mod_gen needs it in order to read module sources back in.             */
/*                                                                       */
/* input 0 "ucd" ucd REQUIRED                                            */
/* input 1 "ucd2" ucd OPTIONAL                                           */
/* input 1 "cmap" colormap OPTIONAL                                      */
/* output 0 "ridge" geom Polyhedron                                 */
/* param 0 "level" typein_real 0.00000 FLOAT_UNBOUND FLOAT_UNBOUND       */
/* param 2 "flip normals" toggle 0 0 1                                   */
/* param 3 "clip lower data" toggle 0 0 1                                   */
/* param 4 "clip higher data" toggle 0 0 1                                   */
/* param 5 "surface title" text "surface" "" ":"                         */
/* param 6 "select for surface" radio_buttons "" "1:2:3:4:5:6:7:8" ":"   */
/* param 7 "color title" text "color" "" ":"                             */
/* param 8 "select for color" radio_buttons "" "1:2:3:4:5:6:7:8" ":"     */
/* param 9 "status" textblock "" "" ":"                                  */
/* End of Module Description Comments                                    */

// ### TODO adapt defs above

#include <stdio.h>
#include <avs/avs.h>
#include <avs/port.h>
#include <avs/geom.h>
#include <avs/ucd_defs.h>
#include <avs/colormap.h>

/* ----> START OF USER-SUPPLIED CODE SECTION #1 (INCLUDE FILES, GLOBAL VARIABLES)*/

#include <stdlib.h>
#include <sys/types.h>
#include <math.h>
#include <vector>
#include <map>
#include <values.h>

#include "unisys.h"
#include "unstructured.h"
#include "ridge_surface_impl.cpp" // ### including .cpp

#define CLEANUP 1

#define MO_SEP ":"
#define MO_CELL_PCA "cell nodes PCA"
#define MO_EDGE_PCA "edge nodes PCA"
#define MO_ALL MO_CELL_PCA MO_SEP MO_EDGE_PCA

#define EX_SEP ":"
#define EX_MAX "maximum ridges"
#define EX_MIN "minimum ridges"
#define EX_ALL EX_MAX EX_SEP EX_MIN

static Unstructured *unst = NULL;
#if SUPPORT_COLORMAP
static Unstructured *unst2 = NULL;
#endif
static Unstructured *temp = NULL;
//static UCD_structure *ucd_temp = NULL;
static bool *excludeNodes = NULL;

#if NORMALS_FROM_GRAD
#define det3(a0, a1, a2, b0, b1, b2, c0, c1, c2) ( \
    (a0) * (b1) * (c2)                             \
    + (a1) * (b2) * (c0)                           \
    + (a2) * (b0) * (c1)                           \
    - (a2) * (b1) * (c0)                           \
    - (a0) * (b2) * (c1)                           \
    - (a1) * (b0) * (c2))
void fvec3norm(fvec3 x, fvec3 y);
#endif

#if SUPPORT_COLORMAP
void HSV_to_RGB(float h, float s, float v, float *r, float *g, float *b);
void getColorMap(AVScolormap *cmap, float RGB[MAXCOLORS][3], float *lower, float *upper);
int nComponents(UCD_structure *ucd);
char *assembleChoiceList(UCD_structure *ucd, char label[100][MAXLABELSIZE], float *data_start[100]);
#endif

/* <---- END OF USER-SUPPLIED CODE SECTION #1                            */

/* *****************************************/
/*  Module Description                     */
/* *****************************************/
int ucd_ridge_surface_desc()
{

    int in_port, out_port, param;
    extern int ucd_ridge_surface_compute(
        UCD_structure * ucd,
#if SUPPORT_COLORMAP
        UCD_structure * ucd2,
        AVScolormap * cmap,
#endif
        GEOMedit_list * ridges,
#if !CLEANUP
        UCD_structure * *debug,
#endif
#if EXTERNAL_DATA
        char *hess_eigenvect,
        char *gradient,
#else
        char *scalar,
#endif
        char *clip_scalar,
#if !CLEANUP
        float *level,
#endif
        int smoothing_range,
        char *mode,
        char *extremum,
        int use_bisection,
        int exclude_FLT_MAX,
        int exclude_lonely_nodes,
        float *Hess_extr_eigenval_min,
        float *PCA_subdom_maxperc,
        float *scalar_min,
        float *scalar_max,
        float *clip_scalar_min,
        float *clip_scalar_max,
        int min_size,
        int filter_by_cell,
        int combine_excpetions,
        int max_exceptions,
        float *clip_min_x,
        float *clip_max_x,
        float *clip_min_y,
        float *clip_max_y,
        float *clip_min_z,
        float *clip_max_z
#if !CLEANUP
        ,
        int flip_normals,
        int clip_lower_data,
        int clip_higher_data,
        char *surface_title,
        char *select_for_surface,
        char *color_title,
        char *select_for_color,
        char *status
#endif
        );

    AVSset_module_name("ucd ridge surface", MODULE_MAPPER);

    /* Input Port Specifications               */
    in_port = AVScreate_input_port("ucd", "ucd", REQUIRED);
#if SUPPORT_COLORMAP
    in_port = AVScreate_input_port("ucd2", "ucd", OPTIONAL);
    in_port = AVScreate_input_port("cmap", "colormap", OPTIONAL);
#endif

    /* Output Port Specifications              */
    out_port = AVScreate_output_port("ridges", "geom");
#if !CLEANUP
    out_port = AVScreate_output_port("debug", "ucd");
#endif

/* Parameter Specifications                */
#if EXTERNAL_DATA
    param = AVSadd_parameter("Hess Eigenvect", "choice", "", "", ":");
    AVSconnect_widget(param, "choice_browser");

    param = AVSadd_parameter("gradient", "choice", "", "", ":");
    AVSconnect_widget(param, "choice_browser");
#else
    param = AVSadd_parameter("scalar", "choice", "", "", ":");
    AVSconnect_widget(param, "choice_browser");
#endif

    param = AVSadd_parameter("clip scalar", "choice", "", "", ":");
    AVSconnect_widget(param, "choice_browser");

#if !CLEANUP
    param = AVSadd_float_parameter("level", 0.00000, FLOAT_UNBOUND,
                                   FLOAT_UNBOUND);
    AVSconnect_widget(param, "typein_real");
#endif

    param = AVSadd_parameter("smoothing range", "integer", 1, 1, INT_MAX);
    AVSconnect_widget(param, "typein_integer");

    param = AVSadd_parameter("mode", "choice", MO_CELL_PCA, MO_ALL, MO_SEP);
    AVSconnect_widget(param, "radio_buttons");

    param = AVSadd_parameter("extremum", "choice", EX_MAX, EX_ALL, EX_SEP);
    AVSconnect_widget(param, "radio_buttons");

    param = AVSadd_parameter("use bisection", "boolean", 0, 0, 1);
    AVSconnect_widget(param, "toggle");

    param = AVSadd_parameter("exclude FLT_MAX", "boolean", 1, 0, 1);
    AVSconnect_widget(param, "toggle");

    param = AVSadd_parameter("exclude lonely nds", "boolean", 1, 0, 1);
    AVSconnect_widget(param, "toggle");

    param = AVSadd_float_parameter("Hess extr. eigenval min", 0.00000, 0.0,
                                   FLOAT_UNBOUND);
    AVSconnect_widget(param, "typein_real");

    param = AVSadd_float_parameter("PCA subdom maxperc", 1.0, 0.0, 1.0);
    AVSconnect_widget(param, "typein_real");

    param = AVSadd_float_parameter("scalar min", 0.00000, FLOAT_UNBOUND,
                                   FLOAT_UNBOUND);
    AVSconnect_widget(param, "typein_real");

    param = AVSadd_float_parameter("scalar max", 100000000000000000000.00000, FLOAT_UNBOUND,
                                   FLOAT_UNBOUND);
    AVSconnect_widget(param, "typein_real");

    param = AVSadd_float_parameter("clip scalar min", 0.00000, FLOAT_UNBOUND, FLOAT_UNBOUND);
    AVSconnect_widget(param, "typein_real");

    param = AVSadd_float_parameter("clip scalar max", 100000000000000000000.00000, FLOAT_UNBOUND, FLOAT_UNBOUND);
    AVSconnect_widget(param, "typein_real");

    param = AVSadd_parameter("min size", "integer", 1, 1, INT_MAX);
    AVSconnect_widget(param, "typein_integer");

    param = AVSadd_parameter("filter by cell", "boolean", 0, 0, 1);
    AVSconnect_widget(param, "toggle");

    param = AVSadd_parameter("combine exceptions", "boolean", 0, 0, 1);
    AVSconnect_widget(param, "toggle");

    param = AVSadd_parameter("max exceptions", "integer", 1, 1, 3);
    AVSconnect_widget(param, "typein_integer");

    param = AVSadd_float_parameter("clip min x", -FLT_MAX, FLOAT_UNBOUND, FLOAT_UNBOUND);
    AVSconnect_widget(param, "typein_real");

    param = AVSadd_float_parameter("clip max x", FLT_MAX, FLOAT_UNBOUND, FLOAT_UNBOUND);
    AVSconnect_widget(param, "typein_real");

    param = AVSadd_float_parameter("clip min y", -FLT_MAX, FLOAT_UNBOUND, FLOAT_UNBOUND);
    AVSconnect_widget(param, "typein_real");

    param = AVSadd_float_parameter("clip max y", FLT_MAX, FLOAT_UNBOUND, FLOAT_UNBOUND);
    AVSconnect_widget(param, "typein_real");

    param = AVSadd_float_parameter("clip min z", -FLT_MAX, FLOAT_UNBOUND, FLOAT_UNBOUND);
    AVSconnect_widget(param, "typein_real");

    param = AVSadd_float_parameter("clip max z", FLT_MAX, FLOAT_UNBOUND, FLOAT_UNBOUND);
    AVSconnect_widget(param, "typein_real");

#if !CLEANUP
    param = AVSadd_parameter("flip normals", "boolean", 0, 0, 1);
    AVSconnect_widget(param, "toggle");
    param = AVSadd_parameter("clip lower data", "boolean", 0, 0, 1);
    AVSconnect_widget(param, "toggle");
    param = AVSadd_parameter("clip higher data", "boolean", 0, 0, 1);
    AVSconnect_widget(param, "toggle");

    param = AVSadd_parameter("surface title", "string", "surface", "",
                             ":");
    AVSconnect_widget(param, "text");
    param = AVSadd_parameter("select for surface", "choice", "",
                             "1:2:3:4:5:6:7:8", ":");
    AVSconnect_widget(param, "radio_buttons");
    param = AVSadd_parameter("color title", "string", "color", "", ":");
    AVSconnect_widget(param, "text");
    param = AVSadd_parameter("select for color", "choice", "",
                             "1:2:3:4:5:6:7:8", ":");
    AVSconnect_widget(param, "radio_buttons");
    param = AVSadd_parameter("status", "string_block", "", "", ":");
    AVSadd_parameter_prop(param, "width", "integer", 4);
    AVSconnect_widget(param, "textblock");
#endif

    AVSset_compute_proc((int (*)())ucd_ridge_surface_compute);
/* ----> START OF USER-SUPPLIED CODE SECTION #2 (ADDITIONAL SPECIFICATION INFO)*/

#if 0
#if EXTERNAL_DATA
  AVSadd_parameter_prop(param, "layout", "string_block"," \n\
        manipulator \"$Module:surface title\" -xy 10,22 -hide \n\
        manipulator \"$Module:color title\" -xy 130,22 \n\
        manipulator \"$Module:select for surface\" -xy 10,44 -hide \n\
        manipulator \"$Module:select for color\" -xy 130,44 -hide \n\
        manipulator \"$Module:Hess Eigenvect\" -xy 10,44 \n\
        manipulator \"$Module:gradient\" -xy 130,44 \n\
        manipulator \"$Module:level\" -xy 10,230 \n\
        manipulator \"$Module:clip higher data\" -xy 10,292 \n\
        manipulator \"$Module:clip lower data\" -xy 10,314 \n\
        manipulator \"$Module:flip normals\" -xy 10,360 \n\
        manipulator \"$Module:status\" -xy 10,390 \n\
        ");
#else
  AVSadd_parameter_prop(param, "layout", "string_block"," \n\
        manipulator \"$Module:surface title\" -xy 10,22 -hide \n\
        manipulator \"$Module:color title\" -xy 130,22 \n\
        manipulator \"$Module:select for surface\" -xy 10,44 -hide \n\
        manipulator \"$Module:select for color\" -xy 130,44 -hide \n\
        manipulator \"$Module:scalar\" -xy 10,44 \n\
        manipulator \"$Module:level\" -xy 10,230 \n\
        manipulator \"$Module:clip higher data\" -xy 10,292 \n\
        manipulator \"$Module:clip lower data\" -xy 10,314 \n\
        manipulator \"$Module:flip normals\" -xy 10,360 \n\
        manipulator \"$Module:status\" -xy 10,390 \n\
        ");
#endif
#else
#if !CLEANUP
    AVSadd_parameter_prop(param, "layout", "string_block", " \n\
        manipulator \"$Module:surface title\" -xy 10,22 -hide \n\
        manipulator \"$Module:color title\" -xy 130,22 -hide \n\
        manipulator \"$Module:select for surface\" -xy 10,44 -hide \n\
        manipulator \"$Module:select for color\" -xy 130,44 -hide \n\
        ");
#endif
#endif

    /* <---- END OF USER-SUPPLIED CODE SECTION #2                            */
    return (1);
}

/* *****************************************/
/* Module Compute Routine                  */
/* *****************************************/
int ucd_ridge_surface_compute(
    UCD_structure *ucd,
#if SUPPORT_COLORMAP
    UCD_structure *ucd2,
    AVScolormap *cmap,
#endif
    GEOMedit_list *ridges,
#if !CLEANUP
    UCD_structure **debug,
#endif
#if EXTERNAL_DATA
    char *hess_eigenvect,
    char *gradient,
#else
    char *scalar,
#endif
    char *clip_scalar,
#if !CLEANUP
    float *level,
#endif
    int smoothing_range,
    char *mode,
    char *extremum,
    int use_bisection,
    int exclude_FLT_MAX,
    int exclude_lonely_nodes,
    float *Hess_extr_eigenval_min,
    float *PCA_subdom_maxperc,
    float *scalar_min,
    float *scalar_max,
    float *clip_scalar_min,
    float *clip_scalar_max,
    int min_size,
    int filter_by_cell,
    int combine_exceptions,
    int max_exceptions,
    float *clip_min_x,
    float *clip_max_x,
    float *clip_min_y,
    float *clip_max_y,
    float *clip_min_z,
    float *clip_max_z
#if !CLEANUP
    ,
    int flip_normals,
    int clip_lower_data,
    int clip_higher_data,
    char *surface_title,
    char *select_for_surface,
    char *color_title,
    char *select_for_color,
    char *status
#endif
    )
{

    /* ----> START OF USER-SUPPLIED CODE SECTION #3 (COMPUTE ROUTINE BODY)   */

    // system wrapper
    UniSys us;

#if SUPPORT_COLORMAP
    AVSparameter_visible("color title", cmap != NULL);
    AVSparameter_visible("select for color", cmap != NULL);

    /* Get the color map */
    float lower, upper;
    if (cmap != NULL)
        getColorMap(cmap, RGB, &lower, &upper);
#endif

    // generate UCD wrapper for input
    if (AVSinput_changed("ucd", 0))
    {
        if (unst)
            delete unst;
        unst = new Unstructured(ucd);

        unst->divideVelocityByWalldist = false;
        unst->extrapolateToNoSlipBoundary = false;
    }
#if SUPPORT_COLORMAP
    if (ucd2 && AVSinput_changed("ucd2", 0))
    {
        if (unst2)
            delete unst2;
        unst2 = new Unstructured(ucd2);

        unst2->divideVelocityByWalldist = false;
        unst2->extrapolateToNoSlipBoundary = false;
    }
#endif

#if EXTERNAL_DATA
    int compHessEigenvect = ucd_processCompChoice(ucd, "ucd", hess_eigenvect, "Hess Eigenvect", 3,
                                                  unst->getVectorNodeDataComponent());
    if (compHessEigenvect >= 0)
        unst->selectVectorNodeData(compHessEigenvect);
    int compGradient = ucd_processCompChoice(ucd, "ucd", gradient, "gradient", 3,
                                             -1);
#else
    int compScalar = ucd_processCompChoice(ucd, "ucd", scalar, "scalar", 1,
                                           unst->getScalarNodeDataComponent());
    if (compScalar >= 0)
        unst->selectScalarNodeData(compScalar);
#endif

    int compClipScalar = -1;
#if 0 // this mode would need to find corresponding nodes of ucd in ucd2
  if (ucd2) {
    compClipScalar = ucd_processCompChoice(ucd2, "ucd2", clip_scalar, "clip scalar", 1,
                                           unst2->getScalarNodeDataComponent());
    if (compClipScalar >= 0) unst2->selectScalarNodeData(compClipScalar);
  }
#else
    if (ucd_nodeCompNb(ucd, 1) > 1)
    {
        compClipScalar = ucd_processCompChoice(ucd, "ucd", clip_scalar, "clip scalar", 1,
                                               unst->getScalarNodeDataComponent());
        //if (compClipScalar >= 0) unst->selectScalarNodeData(compClipScalar);
    }
#endif

#if SUPPORT_COLORMAP
    ncomponents = nComponents(ucd);
    choice_list = assembleChoiceList(ucd, label, data_start);
#endif

#if SUPPORT_COLORMAP

    /* Set surface choice browser contents and separator.  Don't set the default value */
    AVSmodify_parameter("select for surface", AVS_MINVAL | AVS_MAXVAL, 0, choice_list, ":");

    /* Find index of the selected component */
    valid = FALSE;
    if (select_for_surface)
    {
        for (s = 0; s < ncomponents; s++)
        {
            if (strcmp(label[s], select_for_surface) == 0)
            {
                valid = TRUE;
                break;
            }
        }
    }

    if (!valid)
    { /* If invalid selection, take the 0th */
        s = 0;
        sprintf(str, "%s", label[s]);
        AVSmodify_parameter("select for surface", AVS_VALUE, str, 0, 0);
    }
    surface_data = data_start[s];

    if (cmap)
    {
        if (ucd2)
        {
            ncomponents = nComponents(ucd2);
            free(choice_list);
            choice_list = assembleChoiceList(ucd2, label, data_start);
        }

        /* Set color choice browser contents and separator.  Don't set the default value */
        AVSmodify_parameter("select for color", AVS_MINVAL | AVS_MAXVAL, 0, choice_list, ":");

        /* Find index of the selected component */
        valid = FALSE;
        for (s = 0; s < ncomponents; s++)
        {
            if (strcmp(label[s], select_for_color) == 0)
            {
                valid = TRUE;
                break;
            }
        }

        if (!valid)
        { /* If invalid selection, take the 0th */
            s = 0;
            sprintf(str, "%s", label[s]);
            AVSmodify_parameter("select for color", AVS_VALUE, str, 0, 0);
        }
        color_data = data_start[s];
    }

    free(choice_list);

#endif

    // geometry wrapper for output
    UniGeom ugeom = UniGeom(ridges);

    // compute
    if (!ridge_surface_impl(&us,
                            unst, compScalar, compClipScalar,
#if SUPPORT_COLORMAP
                            unst2,
#endif
                            &temp,
                            //compGradient, compHess, compEigenvals, compEigenvectExtr,
                            &excludeNodes,
                            //*level,
                            0.0,
                            smoothing_range,
                            AVSchoice_number("mode", mode),
                            AVSchoice_number("extremum", extremum),
                            use_bisection,
                            exclude_FLT_MAX,
                            exclude_lonely_nodes,
                            *Hess_extr_eigenval_min,
                            *PCA_subdom_maxperc,
                            *scalar_min,
                            *scalar_max,
                            *clip_scalar_min,
                            *clip_scalar_max,
                            min_size,
                            filter_by_cell,
                            combine_exceptions,
                            max_exceptions,
                            *clip_min_x,
                            *clip_max_x,
                            *clip_min_y,
                            *clip_max_y,
                            *clip_min_z,
                            *clip_max_z,
                            //clip_lower_data,
                            0,
                            //clip_higher_data,
                            0,
                            1, // generate normals
                            &ugeom))
    {
        return (0);
    }

#if !CLEANUP
#if !EXTERNAL_DATA
//*debug = ucd_temp;
#endif
#endif

    /* <---- END OF USER-SUPPLIED CODE SECTION #3                            */
    return (1);
}

/* ***********************************************************************/
/* Initialization for modules contained in this file.                    */
/* ***********************************************************************/
static int((*mod_list[])()) = {
    ucd_ridge_surface_desc
};
#define NMODS (sizeof(mod_list) / sizeof(char *))

#if __cplusplus
extern "C" {
#endif

void AVSinit_modules()
{
    AVSinit_from_module_list(mod_list, NMODS);
}

#if __cplusplus
}
#endif

/* ----> START OF USER-SUPPLIED CODE SECTION #4 (SUBROUTINES, FUNCTIONS, UTILITY ROUTINES)*/

#if NORMALS_FROM_GRAD
void fvec3norm(fvec3 x, fvec3 y)
{
    float mag;

    mag = sqrtf(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);
    if (mag == 0)
        mag = 1e-19;
    y[0] = x[0] / mag;
    y[1] = x[1] / mag;
    y[2] = x[2] / mag;
}
#endif

#if SUPPORT_COLORMAP

void HSV_to_RGB(float h, float s, float v, float *r, float *g, float *b)
/* Foley, Van Dam, Feiner, Hughes, p.593 */
{
    int hi;
    float hf;
    float p, q, t;

    if (s == 0.)
        *r = *g = *b = v;
    else
    {
        h *= 6;
        if (h > 6.)
            h -= 6.;
        hi = (int)floor(h);
        hf = h - hi;
        p = v * (1 - s);
        q = v * (1 - s * hf);
        t = v * (1 - s * (1. - hf));
        switch (hi)
        {
        case 0:
        case 6:
            *r = v;
            *g = t;
            *b = p;
            break;
        case 1:
            *r = q;
            *g = v;
            *b = p;
            break;
        case 2:
            *r = p;
            *g = v;
            *b = t;
            break;
        case 3:
            *r = p;
            *g = q;
            *b = v;
            break;
        case 4:
            *r = t;
            *g = p;
            *b = v;
            break;
        case 5:
            *r = v;
            *g = p;
            *b = q;
            break;
        }
    }
}

void getColorMap(AVScolormap *cmap, float RGB[MAXCOLORS][3], float *lower, float *upper)
{
    int ci;
    int size;
    float H[MAXCOLORS];
    float S[MAXCOLORS];
    float V[MAXCOLORS];
    float A[MAXCOLORS];

    AVScolormap_get(cmap, MAXCOLORS, &size, lower, upper, H, S, V, A);
    for (ci = 0; ci < MAXCOLORS; ci++)
    {
        HSV_to_RGB(H[ci], S[ci], V[ci],
                   &RGB[ci][0], &RGB[ci][1], &RGB[ci][2]);
    }
}

int nComponents(UCD_structure *ucd)
{
    int ncomponents = 0;
    int *iptr = ucd->node_components;
    int len = ucd->node_veclen;
    while (len > 0)
    {
        len -= *iptr++;
        ncomponents++;
    }
    return ncomponents;
}

char *assembleChoiceList(UCD_structure *ucd, char label[100][MAXLABELSIZE], float *data_start[100])
{
    int ncomponents = nComponents(ucd);
    char *cptr = strdup(ucd->node_labels);
    char *choice_list = (char *)malloc(ncomponents * MAXLABELSIZE);
    choice_list[0] = 0;
    float *fptr = ucd->node_data;
    char delimiter;
    delimiter = *cptr++;
    for (int i = 0; i < ncomponents; i++)
    {
        char *wptr = label[i];
        while (true)
        {
            char c = *cptr++;
            if (c == delimiter || c == 0)
                break;
            *wptr++ = c;
        }
        *wptr++ = 0;
        data_start[i] = fptr;
        if (ucd->node_components[i] == 1)
        { /* Scalar components only */
            strcat(choice_list, label[i]);
            strcat(choice_list, ":");
        }
        fptr += ucd->node_components[i] * ucd->nnodes;
    }
    return choice_list;
}

#endif
