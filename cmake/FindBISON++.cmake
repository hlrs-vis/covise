# - Find bison++ executable and provides macros to generate custom build rules
# The module defines the following variables:
#
#  BISONPP_EXECUTABLE - path to the bison++ program
#  BISONPP_VERSION - version of bison++
#  BISONPP_FOUND - true if the program was found
#
# The minimum required version of bison++ can be specified using the
# standard CMake syntax, e.g. find_package(BISONPP 2.1.3)
#
# If bison++ is found, the module defines the macros:
#  BISONPP_TARGET(<Name> <YaccInput> <CodeOutput> [VERBOSE <file>]
#              [COMPILE_FLAGS <string>])
# which will create  a custom rule to generate  a parser. <YaccInput> is
# the path to  a yacc file. <CodeOutput> is the name  of the source file
# generated by bison++.  A header file is also  be generated, and contains
# the  token  list.  If  COMPILE_FLAGS  option is  specified,  the  next
# parameter is  added in the bison++  command line.  if  VERBOSE option is
# specified, <file> is created  and contains verbose descriptions of the
# grammar and parser. The macro defines a set of variables:
#  BISONPP_${Name}_DEFINED - true is the macro ran successfully
#  BISONPP_${Name}_INPUT - The input source file, an alias for <YaccInput>
#  BISONPP_${Name}_OUTPUT_SOURCE - The source file generated by bison++
#  BISONPP_${Name}_OUTPUT_HEADER - The header file generated by bison++
#  BISONPP_${Name}_OUTPUTS - The sources files generated by bison++
#  BISONPP_${Name}_COMPILE_FLAGS - Options used in the bison++ command line
#
#  ====================================================================
#  Example:
#
#   find_package(BISON)
#   BISONPP_TARGET(MyParser parser.y ${CMAKE_CURRENT_BINARY_DIR}/parser.cpp)
#   add_executable(Foo main.cpp ${BISONPP_MyParser_OUTPUTS})
#  ====================================================================

#=============================================================================
# Copyright 2009 Kitware, Inc.
# Copyright 2006 Tristan Carel
#
# Distributed under the OSI-approved BSD License (the "License");
# see accompanying file Copyright.txt for details.
#
# This software is distributed WITHOUT ANY WARRANTY; without even the
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the License for more information.
#=============================================================================
# (To distribute this file outside of CMake, substitute the full
#  License text for the above reference.)

# FIND_PROGRAM(BISONPP_EXECUTABLE bison++ DOC "path to the bison++ executable")

IF(MSVC)
SET(BISONPP_EXECUTABLE "$ENV{EXTERNLIBS}/BISONPP/bison++" CACHE FILEPATH "path to the bison++ executable")
ELSE(MSVC)
    SET(BISONPP_EXECUTABLE bison++ CACHE FILEPATH "path to the bison++ executable")
ENDIF(MSVC)
MARK_AS_ADVANCED(BISONPP_EXECUTABLE)

IF(BISONPP_EXECUTABLE)
  # the bison++ commands should be executed with the C locale, otherwise
  # the message (which are parsed) may be translated
  SET(_BisonPP_SAVED_LC_ALL "$ENV{LC_ALL}")
  SET(ENV{LC_ALL} C)

  # EXECUTE_PROCESS(COMMAND ${BISONPP_EXECUTABLE} --version
    #   OUTPUT_VARIABLE BISONPP_version_output
    #   ERROR_VARIABLE BISONPP_version_error
    #   RESULT_VARIABLE BISONPP_version_result
    #   OUTPUT_STRIP_TRAILING_WHITESPACE)
    # 
    # SET(ENV{LC_ALL} ${_BisonPP_SAVED_LC_ALL})
    # 
    # IF(NOT ${BISONPP_version_result} EQUAL 0)
    #   MESSAGE(SEND_ERROR "Command \"${BISONPP_EXECUTABLE} --version\" failed with output:\n${BISONPP_version_error}")
    # ELSE()
    #   STRING(REGEX REPLACE "^bison\\+\\+ Version ([^,]+)\n.*" "\\1"
    #     BISONPP_VERSION "${BISONPP_version_output}")
    # ENDIF()

    SET(BISONPP_VERSION "1.21.9-1")
  
  # internal macro
  MACRO(BISONPP_TARGET_option_verbose Name BisonOutput filename)
    LIST(APPEND BISONPP_TARGET_cmdopt "--verbose")
    GET_FILENAME_COMPONENT(BISONPP_TARGET_output_path "${BisonOutput}" PATH)
    GET_FILENAME_COMPONENT(BISONPP_TARGET_output_name "${BisonOutput}" NAME_WE)
    ADD_CUSTOM_COMMAND(OUTPUT ${filename}
      COMMAND ${CMAKE_COMMAND}
      ARGS -E copy
      "${BISONPP_TARGET_output_path}/${BISONPP_TARGET_output_name}.output"
      "${filename}"
      DEPENDS
      "${BISONPP_TARGET_output_path}/${BISONPP_TARGET_output_name}.output"
      COMMENT "[BISON][${Name}] Copying bison++ verbose table to ${filename}"
      WORKING_DIRECTORY ${CMAKE_SOURCE_DIR})
    SET(BISONPP_${Name}_VERBOSE_FILE ${filename})
    LIST(APPEND BISONPP_TARGET_extraoutputs
      "${BISONPP_TARGET_output_path}/${BISONPP_TARGET_output_name}.output")
  ENDMACRO(BISONPP_TARGET_option_verbose)

  # internal macro
  MACRO(BISONPP_TARGET_option_extraopts Options)
    SET(BISONPP_TARGET_extraopts "${Options}")
    SEPARATE_ARGUMENTS(BISONPP_TARGET_extraopts)
    LIST(APPEND BISONPP_TARGET_cmdopt ${BISONPP_TARGET_extraopts})
  ENDMACRO(BISONPP_TARGET_option_extraopts)

  #============================================================
  # BISONPP_TARGET (public macro)
  #============================================================
  #
  MACRO(BISONPP_TARGET Name BisonInput BisonOutput)
    SET(BISONPP_TARGET_output_header "")
    SET(BISONPP_TARGET_cmdopt "")
    SET(BISONPP_TARGET_outputs "${BisonOutput}")
    IF(NOT ${ARGC} EQUAL 3 AND NOT ${ARGC} EQUAL 5 AND NOT ${ARGC} EQUAL 7)
      MESSAGE(SEND_ERROR "Usage")
    ELSE()
      # Parsing parameters
      IF(${ARGC} GREATER 5 OR ${ARGC} EQUAL 5)
        IF("${ARGV3}" STREQUAL "VERBOSE")
          BISONPP_TARGET_option_verbose(${Name} ${BisonOutput} "${ARGV4}")
        ENDIF()
        IF("${ARGV3}" STREQUAL "COMPILE_FLAGS")
          BISONPP_TARGET_option_extraopts("${ARGV4}")
        ENDIF()
      ENDIF()

      IF(${ARGC} EQUAL 7)
        IF("${ARGV5}" STREQUAL "VERBOSE")
          BISONPP_TARGET_option_verbose(${Name} ${BisonOutput} "${ARGV6}")
        ENDIF()

        IF("${ARGV5}" STREQUAL "COMPILE_FLAGS")
          BISONPP_TARGET_option_extraopts("${ARGV6}")
        ENDIF()
      ENDIF()

      # Header's name generated by bison++ (see option -d)
      LIST(APPEND BISONPP_TARGET_cmdopt "-d")
      STRING(REGEX REPLACE "^(.*)(\\.[^.]*)$" "\\2" _fileext "${ARGV2}")
      STRING(REPLACE "c" "h" _fileext ${_fileext})
      STRING(REGEX REPLACE "^(.*)(\\.[^.]*)$" "\\1${_fileext}"
          BISONPP_${Name}_OUTPUT_HEADER "${ARGV2}")
      LIST(APPEND BISONPP_TARGET_outputs "${BISONPP_${Name}_OUTPUT_HEADER}")

      ADD_CUSTOM_COMMAND(OUTPUT ${BISONPP_TARGET_outputs}
        ${BISONPP_TARGET_extraoutputs}
        COMMAND ${BISONPP_EXECUTABLE}
        ARGS ${BISONPP_TARGET_cmdopt} -o ${ARGV2} ${ARGV1}
        DEPENDS ${ARGV1}
        COMMENT "[BISON][${Name}] Building parser with bison++ ${BISONPP_VERSION}"
        WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})

      # define target variables
      SET(BISONPP_${Name}_DEFINED TRUE)
      SET(BISONPP_${Name}_INPUT ${ARGV1})
      SET(BISONPP_${Name}_OUTPUTS ${BISONPP_TARGET_outputs})
      SET(BISONPP_${Name}_COMPILE_FLAGS ${BISONPP_TARGET_cmdopt})
      SET(BISONPP_${Name}_OUTPUT_SOURCE "${BisonOutput}")

    ENDIF(NOT ${ARGC} EQUAL 3 AND NOT ${ARGC} EQUAL 5 AND NOT ${ARGC} EQUAL 7)
  ENDMACRO(BISONPP_TARGET)
  #
  #============================================================

  #============================================================
  # ADD_FLEX_BISONPP_DEPENDENCY (public macro)
  #============================================================
  #
  MACRO(ADD_FLEX_BISONPP_DEPENDENCY FlexTarget BisonTarget)

    IF(NOT FLEX_${FlexTarget}_OUTPUTS)
      MESSAGE(SEND_ERROR "Flex target `${FlexTarget}' does not exists.")
    ENDIF()

    IF(NOT BISONPP_${BisonTarget}_OUTPUT_HEADER)
      MESSAGE(SEND_ERROR "Bison target `${BisonTarget}' does not exists.")
    ENDIF()

    SET_SOURCE_FILES_PROPERTIES(${FLEX_${FlexTarget}_OUTPUTS}
      PROPERTIES OBJECT_DEPENDS ${BISONPP_${BisonTarget}_OUTPUT_HEADER})
  ENDMACRO(ADD_FLEX_BISONPP_DEPENDENCY)
  #============================================================

ENDIF(BISONPP_EXECUTABLE)

INCLUDE(${CMAKE_CURRENT_LIST_DIR}/FindPackageHandleStandardArgs.cmake)
FIND_PACKAGE_HANDLE_STANDARD_ARGS(BISON++ REQUIRED_VARS  BISONPP_EXECUTABLE
                                        VERSION_VAR BISONPP_VERSION)

# FindBISON.cmake ends here
